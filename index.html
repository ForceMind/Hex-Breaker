<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>六边形破坏者 - Hex Breaker</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><polygon points='50,10 80,25 80,55 50,70 20,55 20,25' fill='%2387CEEB' stroke='%234682B4' stroke-width='3'/><text x='50' y='45' text-anchor='middle' font-family='Arial' font-size='20' font-weight='bold' fill='%23000'>破</text></svg>" />
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Microsoft YaHei', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        #gameContainer {
            text-align: center;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            max-width: 100vw;
            max-height: 100vh;
            box-sizing: border-box;
        }
        
        #gameCanvas {
            border: 2px solid #333;
            background: white;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            max-height: 70vh;
            touch-action: none;
        }
        
        #gameInfo {
            margin: 5px 0;
            font-size: 16px;
            color: #333;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        #controls {
            margin-top: 5px;
            font-size: 12px;
            color: #666;
            padding: 0 10px;
        }
        
        /* 移动端控制按钮 */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            gap: 20px;
            z-index: 1000;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .control-btn:active {
            transform: scale(0.9);
            background: rgba(200, 200, 200, 0.9);
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            body {
                align-items: flex-start;
                padding: 10px;
            }
            
            #gameContainer {
                padding: 5px;
                width: 100%;
                height: 100vh;
                border-radius: 0;
                display: flex;
                flex-direction: column;
            }
            
            #gameCanvas {
                border: 1px solid #333;
                flex: 1;
                width: 100%;
                height: auto;
            }
            
            #gameInfo {
                font-size: 14px;
                margin: 3px 0;
            }
            
            #controls {
                font-size: 10px;
                margin: 3px 0;
            }
            
            #mobileControls {
                display: flex;
            }
            
            h1 {
                font-size: 20px;
                margin: 5px 0;
            }
        }
        
        @media (max-height: 600px) {
            #gameContainer {
                padding: 2px;
            }
            
            h1 {
                font-size: 16px;
                margin: 2px 0;
            }
            
            #gameInfo {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>六边形破坏者</h1>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="gameInfo">
            <div>得分: <span id="score">0</span> | 等级: <span id="level">1</span> | 生命: <span id="lives">3</span></div>
            <div>武器: <span id="weapon">默认</span> | 模式: <span id="pattern">传统</span></div>
            <div id="upgrades" style="font-size: 12px; color: #666; margin-top: 5px;">
                永久增益: <span id="upgradeList">无</span>
            </div>
        </div>
        <div id="controls">
            PC: 使用左右箭头键移动 | 空格键开始游戏<br>
            手机: 触摸屏幕移动 | 点击屏幕开始游戏
        </div>
        
        <!-- 移动端控制按钮 -->
        <div id="mobileControls">
            <div class="control-btn" id="leftBtn">←</div>
            <div class="control-btn" id="rightBtn">→</div>
        </div>
    </div>

    <script>
        // 游戏画布和上下文
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 动态调整画布大小
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const maxWidth = Math.min(800, window.innerWidth - 40);
            const maxHeight = Math.min(600, window.innerHeight * 0.7);
            
            if (window.innerWidth <= 768) {
                // 移动端适配
                canvas.width = Math.min(400, window.innerWidth - 20);
                canvas.height = Math.min(600, window.innerHeight - 150);
            } else {
                // 桌面端
                canvas.width = maxWidth;
                canvas.height = maxHeight;
            }
        }
        
        // 初始化画布大小
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 帧率控制 - 解决高刷新率问题
        let lastTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        
        // 游戏状态
        let gameState = 'menu'; // 'menu', 'playing', 'gameOver'
        let score = 0;
        let gameSpeed = 1;
        let level = 1;
        let lives = 3; // 玩家生命值
        let currentTilePattern = '传统'; // 当前瓦片模式
        // 不再需要瓦片生成计时器，改为基于位置检测
        
        // 玩家类
        class Player {
            constructor() {
                this.width = 40;
                this.height = 40;
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height - this.height - 20;
                this.speed = 5;
                this.weapons = {
                    'default': { active: true, level: 1, duration: 0, maxDuration: 0 },
                    'uzi': { active: false, level: 1, duration: 0, maxDuration: 0 },
                    'shotgun': { active: false, level: 1, duration: 0, maxDuration: 0 },
                    'laser': { active: false, level: 1, duration: 0, maxDuration: 0 },
                    'spread': { active: false, level: 1, duration: 0, maxDuration: 0 }
                };
                this.weaponCooldown = 0;
                this.shield = false;
                this.shieldDuration = 0;
                
                // 永久增益属性
                this.doubleBullets = false;      // 双子弹
                this.speedBoost = 0;             // 速度增加
                this.rapidFire = false;          // 快速射击
                this.piercingBullets = false;    // 穿透子弹
                this.shieldBooster = false;      // 护盾增强器
                this.magneticRange = 0;          // 磁力拾取范围
                this.bulletSizeBoost = 0;        // 子弹尺寸增加
                this.weaponDurationBoost = 1.0;  // 武器持续时间倍数
                
                // 初始化武器显示
                this.updateWeaponDisplay();
            }
            
            update() {
                // 更新所有武器状态
                Object.keys(this.weapons).forEach(weaponType => {
                    if (this.weapons[weaponType].duration > 0) {
                        this.weapons[weaponType].duration--;
                        if (this.weapons[weaponType].duration <= 0) {
                            this.weapons[weaponType].active = false;
                            this.weapons[weaponType].level = 1;
                            this.weapons[weaponType].maxDuration = 0;
                        }
                    }
                });
                
                // 确保默认武器始终激活
                this.weapons.default.active = true;
                
                // 更新武器显示
                this.updateWeaponDisplay();
                
                // 更新护盾状态
                if (this.shieldDuration > 0) {
                    this.shieldDuration--;
                    if (this.shieldDuration <= 0) {
                        this.shield = false;
                    }
                }
                
                // 武器冷却
                if (this.weaponCooldown > 0) {
                    this.weaponCooldown--;
                }
                
                // 磁力拾取道具
                if (this.magneticRange > 0) {
                    itemDrops.forEach(item => {
                        const dx = item.x - (this.x + this.width/2);
                        const dy = item.y - (this.y + this.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < this.magneticRange) {
                            // 磁力吸引
                            const attractionForce = 0.3;
                            item.x -= dx * attractionForce;
                            item.y -= dy * attractionForce;
                        }
                    });
                }
                
                // 自动射击
                this.shoot();
                
                // 检查与瓦片碰撞
                this.checkTileCollision();
            }
            
            updateWeaponDisplay() {
                const activeWeapons = [];
                const weaponNames = {
                    'default': '默认',
                    'uzi': '冲锋枪',
                    'shotgun': '霰弹枪',
                    'laser': '激光炮',
                    'spread': '散射枪'
                };
                
                Object.keys(this.weapons).forEach(weaponType => {
                    if (this.weapons[weaponType].active && weaponType !== 'default') {
                        activeWeapons.push(`${weaponNames[weaponType]}Lv${this.weapons[weaponType].level}`);
                    }
                });
                
                const weaponText = activeWeapons.length > 0 ? activeWeapons.join(', ') : '默认';
                document.getElementById('weapon').textContent = weaponText;
            }
            
            draw() {
                // 绘制护盾效果
                if (this.shield) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, 30, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // 绘制护盾进度条
                    this.drawShieldProgressBar();
                }
                
                // 绘制玩家（黄色方块带光晕）
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#ffdd00';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            moveLeft() {
                if (this.x > 0) {
                    this.x -= (this.speed + this.speedBoost);
                }
            }
            
            moveRight() {
                if (this.x < canvas.width - this.width) {
                    this.x += (this.speed + this.speedBoost);
                }
            }
            
            shoot() {
                if (this.weaponCooldown > 0) return;
                
                const centerX = this.x + this.width/2;
                const centerY = this.y;
                
                // 计算快速射击的冷却时间减少
                const cooldownMultiplier = this.rapidFire ? 0.5 : 1.0;
                let shotsFired = false;
                let maxCooldown = 0;
                
                // 遍历所有激活的武器
                Object.keys(this.weapons).forEach(weaponType => {
                    if (!this.weapons[weaponType].active) return;
                    
                    const weapon = this.weapons[weaponType];
                    let weaponCooldown = 0;
                    
                    switch(weaponType) {
                        case 'default':
                            bullets.push(new Bullet(centerX, centerY, 'normal'));
                            if (this.doubleBullets) {
                                bullets.push(new Bullet(centerX - 8, centerY, 'normal'));
                                bullets.push(new Bullet(centerX + 8, centerY, 'normal'));
                            }
                            weaponCooldown = Math.floor(20 * cooldownMultiplier);
                            break;
                            
                        case 'uzi':
                            bullets.push(new Bullet(centerX, centerY, 'normal'));
                            if (this.doubleBullets) {
                                bullets.push(new Bullet(centerX - 6, centerY, 'normal'));
                                bullets.push(new Bullet(centerX + 6, centerY, 'normal'));
                            }
                            weaponCooldown = Math.floor(Math.max(4, 12 - weapon.level * 2) * cooldownMultiplier);
                            break;
                            
                        case 'shotgun':
                            const shotgunSpread = Math.min(2 + weapon.level, 5);
                            for (let i = -(shotgunSpread-1)/2; i <= (shotgunSpread-1)/2; i++) {
                                bullets.push(new Bullet(centerX + i * 15, centerY, 'normal', i * 0.5));
                            }
                            if (this.doubleBullets) {
                                for (let i = -(shotgunSpread-1)/2; i <= (shotgunSpread-1)/2; i++) {
                                    bullets.push(new Bullet(centerX + i * 15, centerY - 10, 'normal', i * 0.5));
                                }
                            }
                            weaponCooldown = Math.floor(30 * cooldownMultiplier);
                            break;
                            
                        case 'laser':
                            bullets.push(new Bullet(centerX, centerY, 'laser'));
                            if (this.doubleBullets) {
                                bullets.push(new Bullet(centerX - 10, centerY, 'laser'));
                                bullets.push(new Bullet(centerX + 10, centerY, 'laser'));
                            }
                            weaponCooldown = Math.floor(Math.max(8, 18 - weapon.level * 2) * cooldownMultiplier);
                            break;
                            
                        case 'spread':
                            const spreadCount = Math.min(3 + weapon.level, 7);
                            for (let i = -(spreadCount-1)/2; i <= (spreadCount-1)/2; i++) {
                                bullets.push(new Bullet(centerX, centerY, 'small', i * 0.3));
                            }
                            if (this.doubleBullets) {
                                for (let i = -(spreadCount-1)/2; i <= (spreadCount-1)/2; i++) {
                                    bullets.push(new Bullet(centerX, centerY - 8, 'small', i * 0.3));
                                }
                            }
                            weaponCooldown = Math.floor(25 * cooldownMultiplier);
                            break;
                    }
                    
                    if (weaponCooldown > 0) {
                        shotsFired = true;
                        maxCooldown = Math.max(maxCooldown, weaponCooldown);
                    }
                });
                
                if (shotsFired) {
                    this.weaponCooldown = maxCooldown;
                }
            }
            
            checkTileCollision() {
                tiles.forEach(tile => {
                    if (!tile.active) return;
                    
                    if (this.x < tile.x + tile.size &&
                        this.x + this.width > tile.x &&
                        this.y < tile.y + tile.size &&
                        this.y + this.height > tile.y) {
                        
                        if (this.shield) {
                            // 护盾激活时，护盾和瓦片一起消失
                            this.shield = false;
                            this.shieldDuration = 0;
                            tile.active = false;
                            this.showUpgradeMessage('护盾抵挡了攻击！');
                        } else {
                            // 没有护盾时扣除生命值
                            lives--;
                            document.getElementById('lives').textContent = lives;
                            tile.active = false; // 碰撞的瓦片也消失
                            
                            if (lives <= 0) {
                                gameState = 'gameOver';
                            } else {
                                // 还有生命时，给玩家短暂无敌时间
                                this.shield = true;
                                this.shieldDuration = 120; // 2秒无敌时间
                                this.showUpgradeMessage(`生命-1! 剩余${lives}条生命`);
                            }
                        }
                    }
                });
            }
            
            pickupItem(itemType) {
                switch(itemType) {
                    case 'uzi':
                    case 'shotgun':
                    case 'laser':
                    case 'spread':
                        if (this.weapons[itemType].active) {
                            // 相同武器升级
                            this.weapons[itemType].level = Math.min(this.weapons[itemType].level + 1, 5); // 最高5级
                            const bonusTime = this.calculateWeaponDuration(itemType) * 0.5; // 升级奖励50%时间
                            this.weapons[itemType].duration += bonusTime;
                            this.weapons[itemType].maxDuration += bonusTime;
                        } else {
                            // 激活新武器
                            const baseDuration = this.calculateWeaponDuration(itemType);
                            this.weapons[itemType] = {
                                active: true,
                                level: 1,
                                duration: baseDuration,
                                maxDuration: baseDuration
                            };
                        }
                        this.updateWeaponDisplay();
                        break;
                    case 'bomb':
                        this.useBomb('normal');
                        break;
                    case 'bigbomb':
                        this.useBomb('big');
                        break;
                    case 'diagonalbomb':
                        this.useBomb('diagonal');
                        break;
                    case 'horizontalbomb':
                        this.useBomb('horizontal');
                        break;
                    case 'linebomb':
                        this.useBomb('line');
                        break;
                    case 'shield':
                        this.shield = true;
                        this.shieldDuration = 300; // 5秒护盾
                        break;
                    case 'boomerang':
                        this.throwBoomerang();
                        break;
                    // 永久增益道具
                    case 'doublebullets':
                        this.doubleBullets = true;
                        this.showUpgradeMessage('双子弹激活！');
                        this.updateUpgradeDisplay();
                        break;
                    case 'speedboost':
                        this.speedBoost += 2;
                        this.showUpgradeMessage('移动速度增加！');
                        this.updateUpgradeDisplay();
                        break;
                    case 'rapidfire':
                        this.rapidFire = true;
                        this.showUpgradeMessage('快速射击激活！');
                        this.updateUpgradeDisplay();
                        break;
                    case 'piercing':
                        this.piercingBullets = true;
                        this.showUpgradeMessage('穿透子弹激活！');
                        this.updateUpgradeDisplay();
                        break;
                    case 'shieldbooster':
                        this.shieldBooster = true;
                        this.shield = true;
                        this.shieldDuration = 600; // 10秒强化护盾
                        this.showUpgradeMessage('强化护盾激活！');
                        this.updateUpgradeDisplay();
                        break;
                    case 'magnet':
                        this.magneticRange += 50;
                        this.showUpgradeMessage('磁力拾取范围增加！');
                        this.updateUpgradeDisplay();
                        break;
                    case 'bigbullets':
                        if (this.bulletSizeBoost < 8) { // 设置子弹尺寸上限为8
                            this.bulletSizeBoost += 2;
                            this.showUpgradeMessage('子弹尺寸增加！');
                            this.updateUpgradeDisplay();
                        } else {
                            this.showUpgradeMessage('子弹尺寸已达上限！');
                        }
                        break;
                    case 'weaponduration':
                        this.weaponDurationBoost += 0.5;
                        this.showUpgradeMessage('武器持续时间延长！');
                        this.updateUpgradeDisplay();
                        break;
                    case 'extralife':
                        if (lives < 9) { // 最大生命值限制为9
                            lives += 1;
                            this.showUpgradeMessage('生命+1！');
                            document.getElementById('lives').textContent = lives;
                        } else {
                            this.showUpgradeMessage('生命已满！');
                        }
                        break;
                }
            }
            
            showUpgradeMessage(message) {
                // 创建一个临时的升级提示
                const upgradeDiv = document.createElement('div');
                upgradeDiv.textContent = message;
                upgradeDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 255, 0, 0.9);
                    color: white;
                    padding: 10px 20px;
                    border-radius: 5px;
                    font-size: 18px;
                    font-weight: bold;
                    z-index: 1000;
                    animation: fadeOut 2s ease-out forwards;
                `;
                
                // 添加CSS动画
                if (!document.getElementById('upgradeStyles')) {
                    const style = document.createElement('style');
                    style.id = 'upgradeStyles';
                    style.textContent = `
                        @keyframes fadeOut {
                            0% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(upgradeDiv);
                
                // 2秒后移除
                setTimeout(() => {
                    if (upgradeDiv.parentNode) {
                        upgradeDiv.parentNode.removeChild(upgradeDiv);
                    }
                }, 2000);
            }
            
            updateUpgradeDisplay() {
                const upgrades = [];
                if (this.doubleBullets) upgrades.push('双子弹');
                if (this.speedBoost > 0) upgrades.push(`加速+${this.speedBoost}`);
                if (this.rapidFire) upgrades.push('连射');
                if (this.piercingBullets) upgrades.push('穿透');
                if (this.shieldBooster) upgrades.push('强化护盾');
                if (this.magneticRange > 0) upgrades.push(`磁力${Math.floor(this.magneticRange/50)}`);
                if (this.bulletSizeBoost > 0) upgrades.push(`大弹+${this.bulletSizeBoost}`);
                if (this.weaponDurationBoost > 1.0) upgrades.push(`持久+${Math.floor((this.weaponDurationBoost-1)*100)}%`);
                
                document.getElementById('upgradeList').textContent = upgrades.length > 0 ? upgrades.join(', ') : '无';
            }
            
            useBomb(bombType = 'normal') {
                // 发射指定类型的炸弹
                bombs.push(new Bomb(this.x + this.width/2, this.y, bombType));
            }
            
            throwBoomerang() {
                // 创建回旋镖
                boomerangs.push(new Boomerang(this.x + this.width/2, this.y));
            }
            
            calculateWeaponDuration(weaponType) {
                // 基础持续时间：随等级增加而延长，确保后期能找到新道具
                const baseDuration = 600; // 10秒 (60fps)
                const levelBonus = level * 60; // 每级增加1秒
                const weaponBonus = {
                    'uzi': 0,      // 冲锋枪标准时间
                    'shotgun': 60, // 霰弹枪多1秒
                    'laser': 120,  // 激光炮多2秒（更珍贵）
                    'spread': 90   // 散射枪多1.5秒
                };
                
                // 应用武器持续时间增益
                const totalDuration = baseDuration + levelBonus + (weaponBonus[weaponType] || 0);
                return Math.floor(totalDuration * this.weaponDurationBoost);
            }
            
            drawWeaponProgressBar() {
                const activeWeapons = [];
                Object.keys(this.weapons).forEach(weaponType => {
                    if (this.weapons[weaponType].active && weaponType !== 'default') {
                        activeWeapons.push({
                            type: weaponType,
                            ...this.weapons[weaponType]
                        });
                    }
                });
                
                if (activeWeapons.length === 0) return;
                
                // 右下角位置设置
                const rightMargin = 20;
                const bottomMargin = 60; // 从底部开始的距离
                const barWidth = 80;
                const barHeight = 8;
                const barSpacing = 25; // 每个进度条之间的间距
                
                // 为每个武器绘制进度条
                activeWeapons.forEach((weapon, index) => {
                    const barX = canvas.width - rightMargin - barWidth;
                    const barY = canvas.height - bottomMargin - (index * barSpacing);
                    
                    // 计算进度百分比
                    const progress = weapon.duration / weapon.maxDuration;
                    
                    // 进度条背景
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
                    
                    // 进度条外框
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                    
                    // 根据武器类型选择颜色
                    let baseColor;
                    switch(weapon.type) {
                        case 'uzi': baseColor = '#ff6600'; break;
                        case 'shotgun': baseColor = '#ff0066'; break;
                        case 'laser': baseColor = '#0066ff'; break;
                        case 'spread': baseColor = '#66ff00'; break;
                        default: baseColor = '#ffffff'; break;
                    }
                    
                    // 根据剩余时间调整亮度
                    let fillColor;
                    if (progress > 0.6) {
                        fillColor = baseColor;
                    } else if (progress > 0.3) {
                        fillColor = '#ffff00'; // 黄色：时间一般
                    } else {
                        fillColor = '#ff4444'; // 红色：时间紧张
                    }
                    
                    ctx.fillStyle = fillColor;
                    ctx.fillRect(barX, barY, barWidth * progress, barHeight);
                    
                    // 添加闪烁效果当时间不足时
                    if (progress < 0.2 && Math.floor(Date.now() / 200) % 2) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.fillRect(barX, barY, barWidth * progress, barHeight);
                    }
                    
                    // 显示武器名称和等级
                    const weaponNames = {
                        'uzi': '冲锋枪',
                        'shotgun': '霰弹枪',
                        'laser': '激光炮',
                        'spread': '散射枪'
                    };
                    
                    // 绘制文字阴影
                    ctx.fillStyle = '#000000';
                    ctx.font = '12px Microsoft YaHei';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${weaponNames[weapon.type]} Lv${weapon.level}`, barX - 4, barY + 7);
                    
                    // 绘制文字主体
                    ctx.fillStyle = '#ffff00'; // 黄色文字更醒目
                    ctx.fillText(`${weaponNames[weapon.type]} Lv${weapon.level}`, barX - 5, barY + 6);
                    
                    // 显示剩余时间 - 带阴影
                    const remainingSeconds = Math.ceil(weapon.duration / 60);
                    
                    // 时间文字阴影
                    ctx.fillStyle = '#000000';
                    ctx.font = '10px Microsoft YaHei';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${remainingSeconds}s`, barX + barWidth/2 + 1, barY + 19);
                    
                    // 时间文字主体
                    ctx.fillStyle = '#00ff00'; // 绿色时间文字
                    ctx.fillText(`${remainingSeconds}s`, barX + barWidth/2, barY + 18);
                });
            }
            
            drawShieldProgressBar() {
                if (this.shieldDuration <= 0) return;
                
                // 护盾进度条位置和尺寸
                const barWidth = 50;
                const barHeight = 5;
                const barX = this.x + this.width/2 - barWidth/2;
                const barY = this.y + this.height + 35; // 位于玩家下方
                
                // 计算护盾剩余时间比例
                const maxShieldDuration = this.shieldBooster ? 600 : 300; // 强化护盾10秒，普通护盾5秒
                const progress = this.shieldDuration / maxShieldDuration;
                
                // 进度条背景
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);
                
                // 进度条外框
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // 护盾进度条填充 - 青色渐变
                let fillColor;
                if (progress > 0.6) {
                    fillColor = '#00ffff'; // 青色：护盾强度高
                } else if (progress > 0.3) {
                    fillColor = '#00cccc'; // 深青色：护盾一般
                } else {
                    fillColor = '#0088aa'; // 更深：护盾弱
                }
                
                ctx.fillStyle = fillColor;
                ctx.fillRect(barX, barY, barWidth * progress, barHeight);
                
                // 添加闪烁效果当护盾即将消失时
                if (progress < 0.2 && Math.floor(Date.now() / 150) % 2) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fillRect(barX, barY, barWidth * progress, barHeight);
                }
                
                // 显示护盾剩余时间（秒）
                const remainingSeconds = Math.ceil(this.shieldDuration / 60);
                ctx.fillStyle = '#00ffff';
                ctx.font = '9px Microsoft YaHei';
                ctx.textAlign = 'center';
                ctx.fillText(`护盾 ${remainingSeconds}s`, barX + barWidth/2, barY - 2);
            }
        }
        
        // 子弹类
        class Bullet {
            constructor(x, y, type = 'normal', angleOffset = 0) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.angleOffset = angleOffset;
                this.speed = type === 'laser' ? 12 : 8;
                this.active = true;
                this.piercing = player.piercingBullets; // 穿透能力
                this.hitCount = 0; // 穿透次数计数
                this.maxHits = this.piercing ? 3 : 1; // 最多穿透3个目标
                
                // 基础尺寸
                let baseRadius;
                switch(type) {
                    case 'normal':
                        baseRadius = 4;
                        this.color = '#00ff00';
                        break;
                    case 'laser':
                        baseRadius = 6;
                        this.color = '#ff0066';
                        break;
                    case 'small':
                        baseRadius = 3;
                        this.color = '#00ccff';
                        break;
                }
                
                // 应用尺寸增益
                this.radius = baseRadius + player.bulletSizeBoost;
            }
            
            update() {
                this.y -= this.speed;
                this.x += this.angleOffset * this.speed;
                if (this.y < 0 || this.x < 0 || this.x > canvas.width) {
                    this.active = false;
                }
            }
            
            draw() {
                ctx.fillStyle = this.color;
                if (this.type === 'laser') {
                    // 激光效果
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.fillRect(this.x - 2, this.y - 10, 4, 20);
                    ctx.shadowBlur = 0;
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            checkCollision(tile) {
                const dx = this.x - (tile.x + tile.size/2);
                const dy = this.y - (tile.y + tile.size/2);
                const distance = Math.sqrt(dx*dx + dy*dy);
                return distance < this.radius + tile.size/2;
            }
        }
        
        // 瓦片类
        class Tile {
            constructor(x, y, health) {
                this.x = x;
                this.y = y;
                this.size = 50;
                this.health = health;
                this.maxHealth = health;
                this.originalHealth = health; // 保存原始血量用于唯一标识
                this.active = true;
                // 根据生命值决定厚度层数
                this.thickness = Math.min(health, 8); // 最多8层厚度
            }
            
            update() {
                // 瓦片向下移动
                this.y += gameSpeed * 0.3;
                
                // 根据当前生命值更新厚度
                this.thickness = Math.min(this.health, 8);
            }
            
            draw() {
                if (!this.active) return;
                
                // 绘制厚度层 - 从下往上绘制
                for (let layer = this.thickness - 1; layer >= 0; layer--) {
                    const layerDepth = layer * 3; // 每层3像素厚度
                    const layerAlpha = Math.max(0.3, 1 - layer * 0.08);
                    
                    // 计算当前层的位置（向左上偏移创造3D效果）
                    const layerX = this.x + this.size/2 - layerDepth * 0.3;
                    const layerY = this.y + this.size/2 - layerDepth * 0.3;
                    
                    // 绘制八边形瓦片层
                    ctx.fillStyle = `rgba(135, 206, 235, ${layerAlpha})`;
                    ctx.strokeStyle = `rgba(70, 130, 180, ${layerAlpha})`;
                    ctx.lineWidth = 1.5;
                    
                    this.drawOctagon(layerX, layerY, this.size/2);
                }
                
                // 绘制顶层的数字（在最顶层）
                const healthRatio = this.health / this.maxHealth;
                if (healthRatio > 0.7) {
                    ctx.fillStyle = '#000';
                } else if (healthRatio > 0.3) {
                    ctx.fillStyle = '#ff6600';
                } else {
                    ctx.fillStyle = '#ff0000';
                }
                
                const fontSize = canvas.width < 500 ? '14px' : '16px';
                ctx.font = `bold ${fontSize} Microsoft YaHei`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 数字显示在最顶层
                const topLayerDepth = (this.thickness - 1) * 3;
                const numberX = this.x + this.size/2 - topLayerDepth * 0.3;
                const numberY = this.y + this.size/2 - topLayerDepth * 0.3;
                ctx.fillText(this.health.toString(), numberX, numberY);
            }
            
            drawOctagon(centerX, centerY, radius) {
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI * 2) / 8;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            takeDamage(damageAmount = 1) {
                this.health -= damageAmount;
                if (this.health <= 0) {
                    this.active = false;
                    score++;
                    document.getElementById('score').textContent = score;
                    
                    // 每摧毁8个瓦片升级
                    if (score % 8 === 0) {
                        level++;
                        gameSpeed += 0.1; // 增加游戏整体速度
                        updateLevelDisplay();
                    }
                    
                    // 随机掉落道具（多样化）
                    const dropChance = Math.min(0.25, 0.08 + level * 0.02);
                    if (Math.random() < dropChance) {
                        // 分级道具解锁系统
                        let availableItems = [];
                        
                        // 1-2级：基础道具
                        if (level >= 1) {
                            availableItems.push('uzi', 'bomb', 'shield');
                        }
                        
                        // 3-4级：扩展武器
                        if (level >= 3) {
                            availableItems.push('shotgun', 'boomerang');
                        }
                        
                        // 5-6级：高级武器
                        if (level >= 5) {
                            availableItems.push('laser', 'bigbomb');
                        }
                        
                        // 7-8级：散射武器和特殊炸弹
                        if (level >= 7) {
                            availableItems.push('spread', 'diagonalbomb', 'horizontalbomb');
                        }
                        
                        // 9-10级：更多特殊炸弹
                        if (level >= 9) {
                            availableItems.push('linebomb');
                        }
                        
                        // 11级+：永久增益道具逐步解锁
                        if (level >= 11) {
                            availableItems.push('speedboost', 'doublebullets');
                        }
                        
                        if (level >= 13) {
                            availableItems.push('rapidfire');
                            // 只有在子弹尺寸未达到上限时才掉落大弹道具
                            if (player.bulletSizeBoost < 8) {
                                availableItems.push('bigbullets');
                            }
                        }
                        
                        if (level >= 15) {
                            availableItems.push('piercing', 'magnet');
                        }
                        
                        if (level >= 18) {
                            availableItems.push('shieldbooster', 'weaponduration');
                        }
                        
                        if (level >= 20) {
                            availableItems.push('extralife');
                        }
                        
                        // 从可用道具中随机选择
                        const randomItem = availableItems[Math.floor(Math.random() * availableItems.length)];
                        
                        itemDrops.push(new ItemDrop(this.x + this.size/2, this.y + this.size/2, randomItem));
                    }
                    return true;
                }
                return false;
            }
        }
        
        // 道具掉落类
        class ItemDrop {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.size = 30;
                this.speed = 2;
                this.active = true;
                this.animationFrame = 0;
            }
            
            update() {
                this.y += this.speed;
                this.animationFrame++;
                
                if (this.y > canvas.height) {
                    this.active = false;
                }
                
                // 检查与玩家的碰撞
                if (this.x < player.x + player.width &&
                    this.x + this.size > player.x &&
                    this.y < player.y + player.height &&
                    this.y + this.size > player.y) {
                    player.pickupItem(this.type);
                    this.active = false;
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x + this.size/2, this.y + this.size/2);
                ctx.rotate(this.animationFrame * 0.1);
                
                // 根据道具类型设置颜色和文字
                const itemConfig = {
                    'uzi': { color: '#ff6600', text: '冲锋枪', textColor: '#fff' },
                    'shotgun': { color: '#8B4513', text: '霰弹枪', textColor: '#fff' },
                    'laser': { color: '#ff0066', text: '激光炮', textColor: '#fff' },
                    'spread': { color: '#00ccff', text: '散射枪', textColor: '#000' },
                    'bomb': { color: '#ff0000', text: '炸弹', textColor: '#fff' },
                    'bigbomb': { color: '#ff8800', text: '大炸弹', textColor: '#fff' },
                    'diagonalbomb': { color: '#ff00ff', text: '斜炸弹', textColor: '#fff' },
                    'horizontalbomb': { color: '#00ffff', text: '横炸弹', textColor: '#000' },
                    'linebomb': { color: '#ff4488', text: '线炸弹', textColor: '#fff' },
                    'shield': { color: '#00ffff', text: '护盾', textColor: '#000' },
                    'boomerang': { color: '#ffff00', text: '回旋镖', textColor: '#000' },
                    // 永久增益道具 - 使用金色和特殊符号
                    'doublebullets': { color: '#ffd700', text: '双子弹', textColor: '#000' },
                    'speedboost': { color: '#00ff88', text: '加速', textColor: '#000' },
                    'rapidfire': { color: '#ff4400', text: '连射', textColor: '#fff' },
                    'piercing': { color: '#8866ff', text: '穿透', textColor: '#fff' },
                    'shieldbooster': { color: '#ff69b4', text: '护盾+', textColor: '#fff' },
                    'magnet': { color: '#4169e1', text: '磁力', textColor: '#fff' },
                    'bigbullets': { color: '#32cd32', text: '大弹', textColor: '#000' },
                    'weaponduration': { color: '#ffa500', text: '持久', textColor: '#000' },
                    'extralife': { color: '#ff1493', text: '生命', textColor: '#fff' }
                };
                
                const config = itemConfig[this.type] || itemConfig['uzi'];
                
                ctx.fillStyle = config.color;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                
                ctx.fillStyle = config.textColor;
                const fontSize = canvas.width < 500 ? '8px' : '10px';
                ctx.font = `${fontSize} Microsoft YaHei`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(config.text, 0, 0);
                
                ctx.restore();
            }
        }
        
        // 炸弹类
        // 炸弹类 - 支持多种类型
        class Bomb {
            constructor(x, y, type = 'normal') {
                this.x = x;
                this.y = y;
                this.startX = x;
                this.startY = y;
                this.radius = 8;
                this.active = true;
                this.exploded = false;
                this.explosionRadius = 0;
                this.explosionTimer = 0;
                this.type = type;
                
                // 根据炸弹类型设置属性
                this.setupBombType();
            }
            
            setupBombType() {
                switch(this.type) {
                    case 'normal':
                        this.speed = 6;
                        this.maxExplosionRadius = 80;
                        this.directionX = 0;
                        this.directionY = -1;
                        this.color = '#ff4444';
                        this.name = '普通炸弹';
                        break;
                    case 'big':
                        this.speed = 5;
                        this.maxExplosionRadius = 120; // 更大爆炸范围
                        this.directionX = 0;
                        this.directionY = -1;
                        this.color = '#ff8800';
                        this.radius = 12;
                        this.name = '大型炸弹';
                        break;
                    case 'diagonal':
                        this.speed = 7;
                        this.maxExplosionRadius = 70;
                        this.directionX = Math.random() > 0.5 ? 0.7 : -0.7; // 随机左斜或右斜
                        this.directionY = -0.7;
                        this.color = '#ff00ff';
                        this.name = '斜射炸弹';
                        break;
                    case 'horizontal':
                        this.speed = 6;
                        this.maxExplosionRadius = 60;
                        this.directionX = Math.random() > 0.5 ? 1 : -1; // 随机左右
                        this.directionY = 0;
                        this.color = '#00ffff';
                        this.name = '横向炸弹';
                        break;
                    case 'line':
                        this.speed = 8;
                        this.maxExplosionRadius = 40;
                        this.directionX = 0;
                        this.directionY = -1;
                        this.color = '#ff4488';
                        this.isLineBomb = true; // 标记为线性爆炸
                        this.name = '线性炸弹';
                        break;
                }
            }
            
            update() {
                if (!this.exploded) {
                    this.x += this.directionX * this.speed;
                    this.y += this.directionY * this.speed;
                    
                    // 检查与瓦片碰撞
                    tiles.forEach(tile => {
                        if (!tile.active || this.exploded) return;
                        
                        const dx = this.x - (tile.x + tile.size/2);
                        const dy = this.y - (tile.y + tile.size/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < this.radius + tile.size/2) {
                            this.explode();
                        }
                    });
                    
                    // 炸弹飞出屏幕
                    if (this.x < -50 || this.x > canvas.width + 50 || this.y < -50 || this.y > canvas.height + 50) {
                        this.active = false;
                    }
                } else {
                    // 爆炸动画
                    this.explosionTimer++;
                    if (this.explosionTimer < 20) {
                        this.explosionRadius = (this.explosionTimer / 20) * this.maxExplosionRadius;
                    } else {
                        this.active = false;
                    }
                }
            }
            
            explode() {
                this.exploded = true;
                this.explosionTimer = 0;
                
                // 根据炸弹类型进行不同的爆炸伤害计算
                tiles.forEach(tile => {
                    if (!tile.active) return;
                    
                    let shouldDamage = false;
                    let distance = 0;
                    
                    if (this.isLineBomb) {
                        // 线性炸弹：只影响垂直线上的瓦片
                        const horizontalDistance = Math.abs(tile.x + tile.size/2 - this.x);
                        const verticalDistance = Math.abs(tile.y + tile.size/2 - this.y);
                        
                        if (horizontalDistance <= 30 && verticalDistance <= this.maxExplosionRadius) {
                            shouldDamage = true;
                            distance = verticalDistance;
                        }
                    } else {
                        // 圆形爆炸
                        const dx = this.x - (tile.x + tile.size/2);
                        const dy = this.y - (tile.y + tile.size/2);
                        distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance <= this.maxExplosionRadius) {
                            shouldDamage = true;
                        }
                    }
                    
                    if (shouldDamage) {
                        // 根据距离和炸弹类型计算伤害
                        const damageRatio = 1 - (distance / this.maxExplosionRadius);
                        let baseDamage = 4;
                        
                        switch(this.type) {
                            case 'big':
                                baseDamage = 8; // 大型炸弹威力更大
                                break;
                            case 'line':
                                baseDamage = 6; // 线性炸弹中等威力但范围精确
                                break;
                        }
                        
                        const damage = Math.max(2, Math.floor(baseDamage * damageRatio));
                        tile.takeDamage(damage);
                    }
                });
            }
            
            draw() {
                if (!this.exploded) {
                    // 绘制飞行中的炸弹
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.color === '#ff4444' ? '#cc0000' : '#000000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // 炸弹闪烁效果
                    if (Math.floor(Date.now() / 100) % 2) {
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // 为特殊炸弹添加标识
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '10px Microsoft YaHei';
                    ctx.textAlign = 'center';
                    let symbol = '';
                    switch(this.type) {
                        case 'big': symbol = '大'; break;
                        case 'diagonal': symbol = '斜'; break;
                        case 'horizontal': symbol = '横'; break;
                        case 'line': symbol = '线'; break;
                    }
                    if (symbol) {
                        ctx.fillText(symbol, this.x, this.y + 3);
                    }
                } else {
                    // 绘制爆炸效果
                    const alpha = 1 - (this.explosionTimer / 20);
                    
                    if (this.isLineBomb) {
                        // 线性爆炸效果 - 垂直条状
                        ctx.fillStyle = `rgba(255, 100, 255, ${alpha * 0.6})`;
                        ctx.fillRect(this.x - 30, this.y - this.explosionRadius, 60, this.explosionRadius * 2);
                        
                        ctx.strokeStyle = `rgba(255, 200, 255, ${alpha})`;
                        ctx.lineWidth = 3;
                        ctx.strokeRect(this.x - 30, this.y - this.explosionRadius, 60, this.explosionRadius * 2);
                    } else {
                        // 圆形爆炸效果
                        ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.6})`;
                        ctx.strokeStyle = `rgba(255, 200, 0, ${alpha})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.explosionRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        
                        // 爆炸火花
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const sparkX = this.x + Math.cos(angle) * this.explosionRadius * 0.8;
                            const sparkY = this.y + Math.sin(angle) * this.explosionRadius * 0.8;
                            
                            ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(sparkX, sparkY, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
        }
        // 回旋镖类
        class Boomerang {
            constructor(x, y) {
                this.startX = x;
                this.startY = y;
                this.x = x;
                this.y = y;
                this.speed = 6;
                this.active = true;
                this.angle = 0;
                this.radius = 15;
                this.time = 0; // 用于计算弧线轨迹
                this.maxTime = 120; // 总飞行时间（2秒）
                this.hitTiles = new Set(); // 记录已经击中的瓦片，防止重复伤害
                this.mode = 'arc'; // 'arc' = 弧线飞行, 'straight' = 直线飞行, 'returning' = 返回玩家
                this.straightDirection = { x: 0, y: -1 }; // 直线飞行方向
                this.canBeCaught = false; // 是否可以被玩家接住
                this.killedTileThisFrame = false; // 本帧是否击杀了瓦片
            }
            
            update() {
                this.angle += 0.4; // 回旋镖旋转
                this.time++;
                this.killedTileThisFrame = false;
                
                if (this.mode === 'arc' && this.time <= this.maxTime) {
                    // 弧线飞行模式
                    const progress = this.time / this.maxTime;
                    
                    // 使用抛物线方程创建弧线轨迹
                    const arcHeight = 150; // 弧线最高点
                    const arcWidth = 200;  // 弧线最远点
                    
                    // X轴：先向左移动，然后返回
                    if (progress < 0.5) {
                        // 前半段：向左移动
                        this.x = this.startX - (progress * 2) * arcWidth;
                    } else {
                        // 后半段：返回
                        const returnProgress = (progress - 0.5) * 2;
                        this.x = this.startX - arcWidth + returnProgress * arcWidth;
                        this.canBeCaught = true; // 返回阶段可以被接住
                    }
                    
                    // Y轴：抛物线轨迹
                    const yOffset = -4 * arcHeight * progress * (1 - progress);
                    this.y = this.startY + yOffset;
                    
                } else if (this.mode === 'straight') {
                    // 直线飞行模式
                    this.x += this.straightDirection.x * this.speed;
                    this.y += this.straightDirection.y * this.speed;
                    
                    // 飞出屏幕则消失
                    if (this.x < -50 || this.x > canvas.width + 50 || this.y < -50 || this.y > canvas.height + 50) {
                        this.active = false;
                        return;
                    }
                } else {
                    // 返回玩家模式
                    this.mode = 'returning';
                    this.canBeCaught = true;
                    const dx = this.startX - this.x;
                    const dy = player.y - this.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < 20) {
                        // 检查玩家是否能接住回旋镖
                        this.checkPlayerCatch();
                        return;
                    }
                    
                    this.x += (dx / distance) * this.speed * 1.5;
                    this.y += (dy / distance) * this.speed * 1.5;
                }
                
                // 检查与瓦片碰撞
                this.checkTileCollisions();
                
                // 检查是否需要切换到直线模式（击杀瓦片后）
                if (this.killedTileThisFrame && this.mode === 'arc') {
                    this.switchToStraightMode();
                }
                
                // 如果回旋镖飞出屏幕太远，强制返回
                if (this.mode === 'arc' && (this.x < -100 || this.x > canvas.width + 100 || this.y < -100)) {
                    this.time = this.maxTime + 1;
                }
            }
            
            checkTileCollisions() {
                tiles.forEach(tile => {
                    if (!tile.active) return;
                    
                    const dx = this.x - (tile.x + tile.size/2);
                    const dy = this.y - (tile.y + tile.size/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // 回旋镖与瓦片碰撞时造成伤害但不停止飞行
                    if (distance < this.radius + tile.size/2) {
                        // 使用瓦片的唯一标识来防止重复伤害
                        const tileId = `${tile.x}_${tile.y}_${tile.originalHealth || tile.health}`;
                        if (!this.hitTiles.has(tileId)) {
                            this.hitTiles.add(tileId);
                            const wasAlive = tile.active;
                            tile.takeDamage(2); // 回旋镖造成2点伤害
                            
                            // 检查是否击杀了瓦片
                            if (wasAlive && !tile.active) {
                                this.killedTileThisFrame = true;
                            }
                        }
                    }
                });
            }
            
            switchToStraightMode() {
                this.mode = 'straight';
                this.canBeCaught = false;
                // 计算当前的飞行方向
                if (this.time <= this.maxTime) {
                    const progress = this.time / this.maxTime;
                    if (progress < 0.5) {
                        // 前半段，继续向左前方飞行
                        this.straightDirection = { x: -0.7, y: -0.7 };
                    } else {
                        // 后半段，改为向前飞行
                        this.straightDirection = { x: 0, y: -1 };
                    }
                } else {
                    // 默认向前
                    this.straightDirection = { x: 0, y: -1 };
                }
                
                // 重置击中瓦片记录，允许在直线模式下重新击中
                this.hitTiles.clear();
            }
            
            checkPlayerCatch() {
                // 检查玩家是否在回旋镖附近
                const dx = this.x - (player.x + player.width/2);
                const dy = this.y - (player.y + player.height/2);
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 30 && this.canBeCaught) {
                    // 玩家接住了回旋镖，重新发射
                    this.relaunch();
                } else {
                    // 没接住，回旋镖消失
                    this.active = false;
                }
            }
            
            relaunch() {
                // 重新发射回旋镖
                this.startX = player.x + player.width/2;
                this.startY = player.y;
                this.x = this.startX;
                this.y = this.startY;
                this.time = 0;
                this.mode = 'arc';
                this.canBeCaught = false;
                this.hitTiles.clear(); // 清除击中记录，允许重新攻击
                this.killedTileThisFrame = false;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // 根据模式绘制不同的轨迹提示
                if (this.mode === 'arc' && this.time < this.maxTime) {
                    // 弧线模式：绘制弧线轨迹
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i < 20; i++) {
                        const futureTime = this.time + i;
                        if (futureTime > this.maxTime) break;
                        
                        const futureProgress = futureTime / this.maxTime;
                        let futureX, futureY;
                        
                        if (futureProgress < 0.5) {
                            futureX = this.startX - (futureProgress * 2) * 200;
                        } else {
                            const returnProgress = (futureProgress - 0.5) * 2;
                            futureX = this.startX - 200 + returnProgress * 200;
                        }
                        
                        const yOffset = -4 * 150 * futureProgress * (1 - futureProgress);
                        futureY = this.startY + yOffset;
                        
                        if (i === 0) {
                            ctx.moveTo(futureX - this.x, futureY - this.y);
                        } else {
                            ctx.lineTo(futureX - this.x, futureY - this.y);
                        }
                    }
                    ctx.stroke();
                } else if (this.mode === 'straight') {
                    // 直线模式：绘制直线轨迹
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(this.straightDirection.x * 100, this.straightDirection.y * 100);
                    ctx.stroke();
                }
                
                // 绘制回旋镖本体
                let boomerangColor = '#ffff00';
                let strokeColor = '#ff6600';
                
                // 根据模式调整颜色
                if (this.mode === 'straight') {
                    boomerangColor = '#ff4444'; // 直线模式时变红
                    strokeColor = '#cc0000';
                } else if (this.canBeCaught) {
                    boomerangColor = '#44ff44'; // 可接住时变绿
                    strokeColor = '#00cc00';
                }
                
                ctx.fillStyle = boomerangColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                
                // 绘制回旋镖形状（更真实的V形）
                ctx.beginPath();
                ctx.moveTo(-15, -3);
                ctx.lineTo(-5, 0);
                ctx.lineTo(0, -8);
                ctx.lineTo(8, 0);
                ctx.lineTo(15, -3);
                ctx.lineTo(12, 0);
                ctx.lineTo(8, 8);
                ctx.lineTo(0, 5);
                ctx.lineTo(-8, 8);
                ctx.lineTo(-12, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        // 游戏对象
        let player = new Player();
        let bullets = [];
        let tiles = [];
        let itemDrops = [];
        let boomerangs = [];
        let bombs = [];
        
        // 创建新的瓦片行
        function createNewTileRow() {
            createNewTileRowAtPosition(-80);
        }
        
        // 在指定Y位置创建新的瓦片行
        function createNewTileRowAtPosition(yPosition) {
            // 计算瓦片数量铺满整个屏幕宽度
            const tileSize = 50;
            const tileSpacing = 55;
            const tilesPerRow = Math.floor(canvas.width / tileSpacing);
            const startX = (canvas.width - (tilesPerRow - 1) * tileSpacing) / 2;
            
            // 高等级时使用形状模式，否则使用传统模式
            if (level >= 3 && Math.random() < 0.8) { // 3级开始，80%概率使用形状模式
                createShapedTileRowAtPosition(tilesPerRow, startX, tileSpacing, tileSize, yPosition);
            } else {
                currentTilePattern = '传统';
                document.getElementById('pattern').textContent = currentTilePattern;
                createFullTileRowAtPosition(tilesPerRow, startX, tileSpacing, tileSize, yPosition);
            }
        }
        
        // 传统的满屏瓦片生成
        function createFullTileRow(tilesPerRow, startX, tileSpacing, tileSize) {
            createFullTileRowAtPosition(tilesPerRow, startX, tileSpacing, tileSize, -80);
        }
        
        function createFullTileRowAtPosition(tilesPerRow, startX, tileSpacing, tileSize, yPosition) {
            for (let col = 0; col < tilesPerRow; col++) {
                const x = startX + col * tileSpacing - tileSize/2;
                const y = yPosition;
                
                // 根据等级调整数字范围：难度递增
                let minHealth, maxHealth;
                if (level <= 2) {
                    minHealth = 1;
                    maxHealth = 3;
                } else if (level <= 4) {
                    minHealth = 1;
                    maxHealth = 5;
                } else if (level <= 6) {
                    minHealth = 2;
                    maxHealth = 7;
                } else if (level <= 8) {
                    minHealth = 3;
                    maxHealth = 9;
                } else if (level <= 10) {
                    minHealth = 4;
                    maxHealth = 12;
                } else if (level <= 15) {
                    minHealth = 5;
                    maxHealth = 15;
                } else {
                    minHealth = Math.floor(level / 2);
                    maxHealth = Math.min(25, level + 10);
                }
                
                const health = Math.floor(Math.random() * (maxHealth - minHealth + 1)) + minHealth;
                const newTile = new Tile(x, y, health);
                tiles.push(newTile);
            }
        }
        
        // 形状模式瓦片生成
        function createShapedTileRow(tilesPerRow, startX, tileSpacing, tileSize) {
            createShapedTileRowAtPosition(tilesPerRow, startX, tileSpacing, tileSize, -80);
        }
        
        function createShapedTileRowAtPosition(tilesPerRow, startX, tileSpacing, tileSize, yPosition) {
            // 定义各种形状模式
            const patterns = [
                'corridor',     // 走廊模式
                'walls',        // 两侧墙壁
                'center',       // 中央集中
                'sides',        // 两侧集中
                'gaps',         // 有间隙的模式
                'zigzag',       // 之字形
                'diamond',      // 菱形
                'wave',         // 波浪形
                'tunnel',       // 隧道模式
                'stairs',       // 阶梯模式
                'cross',        // 十字形
                'random',       // 随机散布
                'barrier'       // 障碍模式
            ];
            
            const patternNames = {
                'corridor': '走廊',
                'walls': '墙壁',
                'center': '中央',
                'sides': '两侧',
                'gaps': '间隙',
                'zigzag': '之字',
                'diamond': '菱形',
                'wave': '波浪',
                'tunnel': '隧道',
                'stairs': '阶梯',
                'cross': '十字',
                'random': '随机',
                'barrier': '障碍'
            };
            
            const pattern = patterns[Math.floor(Math.random() * patterns.length)];
            currentTilePattern = patternNames[pattern];
            document.getElementById('pattern').textContent = currentTilePattern;
            const patternMask = generatePattern(pattern, tilesPerRow);
            
            for (let col = 0; col < tilesPerRow; col++) {
                // 只在模式允许的位置生成瓦片
                if (patternMask[col]) {
                    const x = startX + col * tileSpacing - tileSize/2;
                    const y = yPosition;
                    
                    // 根据等级调整数字范围
                    let minHealth, maxHealth;
                    if (level <= 10) {
                        minHealth = 3;
                        maxHealth = 9;
                    } else if (level <= 15) {
                        minHealth = 5;
                        maxHealth = 15;
                    } else {
                        minHealth = Math.floor(level / 2);
                        maxHealth = Math.min(25, level + 10);
                    }
                    
                    const health = Math.floor(Math.random() * (maxHealth - minHealth + 1)) + minHealth;
                    const newTile = new Tile(x, y, health);
                    tiles.push(newTile);
                }
            }
        }
        
        // 生成不同的形状模式
        function generatePattern(patternType, tilesPerRow) {
            const pattern = new Array(tilesPerRow).fill(false);
            const center = Math.floor(tilesPerRow / 2);
            
            switch(patternType) {
                case 'corridor':
                    // 中央留出走廊
                    for (let i = 0; i < tilesPerRow; i++) {
                        if (i < center - 3 || i > center + 3) {
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'walls':
                    // 两侧墙壁
                    for (let i = 0; i < 2; i++) {
                        pattern[i] = true;
                        pattern[tilesPerRow - 1 - i] = true;
                    }
                    break;
                    
                case 'center':
                    // 中央集中
                    for (let i = center - 2; i <= center + 2; i++) {
                        if (i >= 0 && i < tilesPerRow) {
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'sides':
                    // 两侧集中，中央空白
                    for (let i = 0; i < tilesPerRow; i++) {
                        if (i < tilesPerRow * 0.25 || i > tilesPerRow * 0.75) {
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'gaps':
                    // 有间隙的模式
                    for (let i = 0; i < tilesPerRow; i++) {
                        if (i % 4 === 0 || i % 4 === 1) { // 2个瓦片，2个空隙
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'zigzag':
                    // 之字形
                    for (let i = 0; i < tilesPerRow; i++) {
                        if ((i % 4 === 0) || (i % 4 === 1)) {
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'diamond':
                    // 菱形
                    const diamondSize = Math.min(4, Math.floor(tilesPerRow / 3));
                    for (let i = center - diamondSize; i <= center + diamondSize; i++) {
                        if (i >= 0 && i < tilesPerRow) {
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'wave':
                    // 波浪形
                    for (let i = 0; i < tilesPerRow; i++) {
                        if (Math.sin(i * 0.8) > 0) {
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'tunnel':
                    // 隧道模式 - 上下有瓦片，中间留通道
                    for (let i = 0; i < tilesPerRow; i++) {
                        if (i < 2 || i > tilesPerRow - 3) {
                            pattern[i] = true;
                        } else if (Math.random() < 0.3) { // 30%概率在通道中放置少量瓦片
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'stairs':
                    // 阶梯模式
                    for (let i = 0; i < tilesPerRow; i++) {
                        if (i % 2 === 0 && i < tilesPerRow * 0.8) {
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'cross':
                    // 十字形
                    for (let i = 0; i < tilesPerRow; i++) {
                        if (i === center || i === center - 1 || i === center + 1) {
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'random':
                    // 随机散布 - 约50%密度
                    for (let i = 0; i < tilesPerRow; i++) {
                        if (Math.random() < 0.5) {
                            pattern[i] = true;
                        }
                    }
                    break;
                    
                case 'barrier':
                    // 障碍模式 - 在某些位置放置较密集的障碍
                    const barrierPositions = [
                        Math.floor(tilesPerRow * 0.2),
                        Math.floor(tilesPerRow * 0.5),
                        Math.floor(tilesPerRow * 0.8)
                    ];
                    barrierPositions.forEach(pos => {
                        for (let i = pos - 1; i <= pos + 1; i++) {
                            if (i >= 0 && i < tilesPerRow) {
                                pattern[i] = true;
                            }
                        }
                    });
                    break;
            }
            
            return pattern;
        }
        
        // 更新等级显示
        function updateLevelDisplay() {
            const levelInfo = document.getElementById('level');
            if (levelInfo) {
                levelInfo.textContent = level;
            }
        }
        
        // 键盘输入处理
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'menu' || gameState === 'gameOver') {
                    startGame();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // 移动端按钮控制
        let mobileLeftPressed = false;
        let mobileRightPressed = false;
        
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        
        // 左按钮事件
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mobileLeftPressed = true;
        });
        leftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            mobileLeftPressed = false;
        });
        leftBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            mobileLeftPressed = true;
        });
        leftBtn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            mobileLeftPressed = false;
        });
        
        // 右按钮事件
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mobileRightPressed = true;
        });
        rightBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            mobileRightPressed = false;
        });
        rightBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            mobileRightPressed = true;
        });
        rightBtn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            mobileRightPressed = false;
        });
        
        // 处理玩家移动
        function handleInput() {
            if (keys['ArrowLeft'] || mobileLeftPressed) {
                player.moveLeft();
            }
            if (keys['ArrowRight'] || mobileRightPressed) {
                player.moveRight();
            }
        }
        
        // 碰撞检测
        function checkCollisions() {
            bullets.forEach(bullet => {
                if (!bullet.active) return;
                
                tiles.forEach(tile => {
                    if (!tile.active) return;
                    
                    if (bullet.checkCollision(tile)) {
                        // 处理穿透功能
                        if (bullet.piercing && bullet.hitCount < bullet.maxHits) {
                            bullet.hitCount++;
                        } else {
                            bullet.active = false;
                        }
                        
                        // 根据子弹类型造成不同伤害
                        let damage = 1;
                        if (bullet.type === 'laser') {
                            damage = 3; // 激光炮威力更大
                        }
                        
                        // 大子弹造成额外伤害
                        if (bullet.radius > 6) {
                            damage += Math.floor((bullet.radius - 6) / 2);
                        }
                        
                        tile.takeDamage(damage);
                    }
                });
            });
        }
        
        // 更新游戏
        function update() {
            if (gameState !== 'playing') return;
            
            handleInput();
            
            player.update();
            
            bullets.forEach(bullet => bullet.update());
            bullets = bullets.filter(bullet => bullet.active);
            
            tiles.forEach(tile => tile.update());
            tiles = tiles.filter(tile => tile.active);
            
            itemDrops.forEach(item => item.update());
            itemDrops = itemDrops.filter(item => item.active);
            
            boomerangs.forEach(boomerang => boomerang.update());
            boomerangs = boomerangs.filter(boomerang => boomerang.active);
            
            bombs.forEach(bomb => bomb.update());
            bombs = bombs.filter(bomb => bomb.active);
            
            checkCollisions();
            
            // 基于位置生成新的瓦片行 - 确保连续无空白
            let topMostY = canvas.height;
            let hasActiveTiles = false;
            tiles.forEach(tile => {
                if (tile.active) {
                    hasActiveTiles = true;
                    if (tile.y < topMostY) {
                        topMostY = tile.y;
                    }
                }
            });
            
            // 当最顶部的瓦片Y坐标大于0时（还在屏幕内但已经开始下移），立即生成新瓦片
            if (!hasActiveTiles || topMostY > 0) {
                // 计算新瓦片的Y位置：紧贴最顶部瓦片上方
                const newY = !hasActiveTiles ? 10 : topMostY - 55;
                
                // 使用形状生成系统
                createNewTileRowAtPosition(newY);
            }
            
            // 清理超出屏幕下方的瓦片
            tiles = tiles.filter(tile => tile.y < canvas.height + 100);
        }
        
        // 绘制游戏
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'menu') {
                drawMenu();
            } else if (gameState === 'playing') {
                player.draw();
                bullets.forEach(bullet => bullet.draw());
                tiles.forEach(tile => tile.draw());
                itemDrops.forEach(item => item.draw());
                boomerangs.forEach(boomerang => boomerang.draw());
                bombs.forEach(bomb => bomb.draw());
                
                // 在最后绘制武器进度条，确保显示在最上层
                player.drawWeaponProgressBar();
            } else if (gameState === 'gameOver') {
                drawGameOver();
            }
        }
        
        // 绘制菜单
        function drawMenu() {
            ctx.fillStyle = '#333';
            const titleSize = canvas.width < 500 ? '32px' : '48px';
            ctx.font = `${titleSize} Microsoft YaHei`;
            ctx.textAlign = 'center';
            ctx.fillText('六边形破坏者', canvas.width/2, canvas.height/2 - 50);
            
            const subtitleSize = canvas.width < 500 ? '18px' : '24px';
            ctx.font = `${subtitleSize} Microsoft YaHei`;
            ctx.fillText('点击屏幕或按空格键开始', canvas.width/2, canvas.height/2 + 20);
            
            const infoSize = canvas.width < 500 ? '12px' : '16px';
            ctx.font = `${infoSize} Microsoft YaHei`;
            ctx.fillText('瓦片从顶部生成，数字随等级增长', canvas.width/2, canvas.height/2 + 60);
            ctx.fillText('收集武器和道具强化战斗力', canvas.width/2, canvas.height/2 + 85);
        }
        
        // 绘制游戏结束画面
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#ff0000';
            const titleSize = canvas.width < 500 ? '32px' : '48px';
            ctx.font = `${titleSize} Microsoft YaHei`;
            ctx.textAlign = 'center';
            ctx.fillText('游戏结束', canvas.width/2, canvas.height/2 - 50);
            
            ctx.fillStyle = '#fff';
            const scoreSize = canvas.width < 500 ? '18px' : '24px';
            ctx.font = `${scoreSize} Microsoft YaHei`;
            ctx.fillText(`最终得分: ${score} | 等级: ${level}`, canvas.width/2, canvas.height/2);
            ctx.fillText('点击屏幕或按空格键重新开始', canvas.width/2, canvas.height/2 + 40);
        }
        
        // 开始游戏
        function startGame() {
            gameState = 'playing';
            score = 0;
            level = 1;
            gameSpeed = 1;
            lives = 3; // 重置生命值
            currentTilePattern = '传统'; // 重置瓦片模式
            // 不再需要瓦片生成计时器，改为基于位置检测
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lives').textContent = lives;
            document.getElementById('pattern').textContent = currentTilePattern;

            player = new Player();
            // 更新武器显示
            player.updateWeaponDisplay();
            bullets = [];
            tiles = [];
            itemDrops = [];
            boomerangs = [];
            bombs = [];

            // 初始生成4行瓦片，确保连续无空隙
            const tileSize = 50;
            const tileSpacing = 55;
            const tilesPerRow = Math.floor(canvas.width / tileSpacing);
            const startX = (canvas.width - (tilesPerRow - 1) * tileSpacing) / 2;

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < tilesPerRow; col++) {
                    const x = startX + col * tileSpacing - tileSize/2;
                    const y = row * 55 + 10; // 55像素间距
                    const health = Math.floor(Math.random() * 3) + 1; // 初始简单数字

                    const newTile = new Tile(x, y, health);
                    tiles.push(newTile);
                }
            }
        }        // 游戏主循环 - 帧率控制
        function gameLoop(currentTime) {
            if (currentTime - lastTime >= frameInterval) {
                update();
                draw();
                lastTime = currentTime;
            }
            requestAnimationFrame(gameLoop);
        }
        
        // 初始化游戏
        gameLoop(0);
        
        // 触摸控制（移动设备）- 优化版
        let touchStartX = 0;
        let touchStartY = 0;
        let lastTouchX = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
            lastTouchX = touchStartX;
            
            if (gameState === 'menu' || gameState === 'gameOver') {
                startGame();
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (gameState !== 'playing') return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const currentTouchX = touch.clientX - rect.left;
            const deltaX = currentTouchX - lastTouchX;
            
            // 根据滑动方向移动玩家
            if (Math.abs(deltaX) > 2) { // 增加灵敏度阈值
                if (deltaX > 0) {
                    player.moveRight();
                } else {
                    player.moveLeft();
                }
                lastTouchX = currentTouchX;
            }
        });
        
        // 鼠标点击支持
        canvas.addEventListener('click', (e) => {
            if (gameState === 'menu' || gameState === 'gameOver') {
                startGame();
            }
        });
    </script>
</body>
</html>
